---
{
  "id": "chapter-235",
  "title": "Exploiting Web Application Vulnerabilities",
  "order": 235,
  "source": {
    "href": "c21.xhtml",
    "anchor": "head-2-373"
  },
  "est_tokens": 2383,
  "slug": "exploiting-web-application-vulnerabilities",
  "meta": {
    "nav_title": "Exploiting Web Application Vulnerabilities",
    "enriched_from": "start-heading",
    "kind": "chapter"
  }
}
---
## Exploiting Web Application Vulnerabilities

Web applications are complex ecosystems consisting of application code, web platforms, operating systems, databases, and interconnected application programming interfaces (APIs) . The complexity of these environments, combined with the fact that they are often public-facing, makes many different types of attacks possible and provides fertile ground for penetration testers. We've already looked at a variety of attacks against web applications, including injection attacks, directory traversal, and more. In the following sections, we round out our look at web-based exploits by exploring cross-site scripting, cross-site request forgery, and session hijacking.

### Cross-Site Scripting (XSS)

Cross-site scripting (XSS) attacks occur when web applications allow an attacker to perform HTML injection , inserting their own HTML code into a web page.

#### Reflected XSS

XSS attacks commonly occur when an application allows reflected input . For example, consider a simple web application that contains a single text box asking a user to enter their name. When the user clicks Submit, the web application loads a new page that says, “Hello, name .”

Under normal circumstances, this web application functions as designed. However, a malicious individual could take advantage of this web application to trick an unsuspecting third party. As you may know, you can embed scripts in web pages by using the HTML tags < SCRIPT > and </ SCRIPT >. Suppose that, instead of entering Mike in the Name field, you enter the following text:

`SCRIPT`

`SCRIPT`

```

Mike<SCRIPT>alert('hello')</SCRIPT>
```

`Mike<SCRIPT>alert('hello')</SCRIPT>`

When the web application “reflects” this input in the form of a web page, your browser processes it as it would any other web page: it displays the text portions of the web page and executes the script portions. In this case, the script simply opens a pop-up window that says “hello” in it. However, you could be more malicious and include a more sophisticated script that asks the user to provide a password and transmits it to a malicious third party.

At this point, you're probably asking yourself how anyone would fall victim to this type of attack. After all, you're not going to attack yourself by embedding scripts in the input that you provide to a web application that performs reflection. The key to this attack is that it's possible to embed form input in a link. A malicious individual could create a web page with a link titled “Check your account at First Bank” and encode form input in the link. When the user visits the link, the web page appears to be an authentic First Bank website (because it is!) with the proper address in the toolbar and a valid digital certificate. However, the website would then execute the script included in the input by the malicious user, which appears to be part of the valid web page.

What's the answer to cross-site scripting? When creating web applications that allow any type of user input, developers must be sure to perform input validation . At the most basic level, applications should never allow a user to include the <SCRIPT> tag in a reflected input field. However, this doesn't solve the problem completely; many clever alternatives are available to an industrious web application attacker. The best solution is to determine the type of input that the application will allow and then validate the input to ensure that it matches that pattern. For example, if an application has a text box that allows users to enter their age, it should accept only one to three digits as input. The application should reject any other input as invalid.

`<SCRIPT>`

For more examples of ways to evade cross-site scripting filters, see www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet .

Output encoding is a set of related techniques that take user-supplied input and encode it using a series of rules that transform potentially dangerous content into a safe form. For example, HTML encoding transforms the single quote ' character into the encoded string ' . Developers should be familiar with a variety of output encoding techniques including HTML entity encoding, HTML attribute encoding, URL encoding, JavaScript encoding, and CSS hex encoding. For more information on these techniques, see the OWASP XSS Prevention Cheat Sheet at https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html .

`'`

`'`

#### Stored/Persistent XSS

Cross-site scripting attacks often exploit reflected input, but this isn't the only way that the attacks might take place. Another common technique is to store cross-site scripting code on a remote web server in an approach known as stored XSS . These attacks are described as persistent, because they remain on the server even when the attacker isn't actively waging an attack.

As an example, consider a message board that allows users to post messages that contain HTML code. This is very common, because users may want to use HTML to add emphasis to their posts. For example, a user might use this HTML code in a message board posting:

```

<p>Hello everyone,</p>

<p>I am planning an upcoming trip to <A HREF=

'
https://www.mlb.com/mets/ballpark
'>Citi Field</A> to see the Mets take on the

Yankees in the Subway Series.</p>

<p>Does anyone have suggestions for transportation? I am staying in Manhattan

and am only interested in <B>public transportation</B> options.</p>

<p>Thanks!</p>

<p>Mike</p>
```

`<p>Hello everyone,</p>`

`<p>I am planning an upcoming trip to <A HREF=`

`' https://www.mlb.com/mets/ballpark '>Citi Field</A> to see the Mets take on the`

`Yankees in the Subway Series.</p>`

`<p>Does anyone have suggestions for transportation? I am staying in Manhattan`

`and am only interested in <B>public transportation</B> options.</p>`

`<p>Thanks!</p>`

`<p>Mike</p>`

When displayed in a browser, the HTML tags would alter the appearance of the message, as shown in Figure 21.6 .

FIGURE 21.6 Message board post rendered in a browser

FIGURE 21.6 Message board post rendered in a browser

An attacker seeking to conduct a cross-site scripting attack could try to insert an HTML script in this code. For example, they might enter this code:

```

<p>Hello everyone,</p>

<p>I am planning an upcoming trip to <A HREF=

'
https://www.mlb.com/mets/ballpark
'>Citi Field</A> to see the Mets take on the

Yankees in the Subway Series.</p>

<p>Does anyone have suggestions for transportation? I am staying in Manhattan

and am only interested in <B>public transportation</B> options.</p>

<p>Thanks!</p>

<p>Mike</p>

<SCRIPT>alert('Cross-site scripting!')</SCRIPT>
```

`<p>Hello everyone,</p>`

`<p>I am planning an upcoming trip to <A HREF=`

`' https://www.mlb.com/mets/ballpark '>Citi Field</A> to see the Mets take on the`

`Yankees in the Subway Series.</p>`

`<p>Does anyone have suggestions for transportation? I am staying in Manhattan`

`and am only interested in <B>public transportation</B> options.</p>`

`<p>Thanks!</p>`

`<p>Mike</p>`

`<SCRIPT>alert('Cross-site scripting!')</SCRIPT>`

When future users load this message, they would then see the alert pop-up shown in Figure 21.7 . This is fairly innocuous, but an XSS attack could also be used to redirect users to a phishing site, request sensitive information, or perform another attack.

FIGURE 21.7 XSS attack rendered in a browser

FIGURE 21.7 XSS attack rendered in a browser

Some XSS attacks are particularly sneaky and work by modifying the Document Object Model (DOM) environment within the user's browser. These attacks don't appear in the HTML code of the web page but are still quite dangerous.

### Request Forgery

Request forgery attacks exploit trust relationships and attempt to have users unwittingly execute commands against a remote server. They come in two forms: cross-site request forgery and server-side request forgery.

#### Cross-Site Request Forgery (CSRF/XSRF)

Cross-site request forgery attacks, abbreviated as XSRF or CSRF attacks, are similar to cross-site scripting attacks but exploit a different trust relationship. XSS attacks exploit the trust that a user has in a website to execute code on the user's computer. XSRF attacks exploit the trust that remote sites have in a user's system to execute commands on the user's behalf.

XSRF attacks work by making the reasonable assumption that users are often logged into many different websites at the same time. Attackers then embed code in one website that sends a command to a second website. When the user clicks the link on the first site, they are unknowingly sending a command to the second site. If the user happens to be logged into that second site, the command may succeed.

Consider, for example, an online banking site. An attacker who wants to steal funds from user accounts might go to an online forum and post a message containing a link. That link actually goes directly into the money transfer site that issues a command to transfer funds to the attacker's account. The attacker then leaves the link posted on the forum and waits for an unsuspecting user to come along and click the link. If the user happens to be logged into the banking site, the transfer succeeds.

Developers should protect their web applications against XSRF attacks. One way to do this is to create web applications that use secure tokens that the attacker would not know to embed in the links. Another safeguard is for sites to check the referring URL in requests received from end users and only accept requests that originated from their own site.

#### Server-Side Request Forgery (SSRF)

Server-side request forgery (SSRF) attacks exploit a similar vulnerability but instead of tricking a user's browser into visiting a URL, they trick a server into visiting a URL based on user-supplied input. SSRF attacks are possible when a web application accepts URLs from a user as input and then retrieves information from that URL. If the server has access to non-public URLs, an SSRF attack can unintentionally disclose that information to an attacker.

### Session Hijacking

Session hijacking attacks occur when a malicious individual intercepts part of the communication between an authorized user and a resource and then uses a hijacking technique to take over the session and assume the identity of the authorized user. The following list includes some common techniques:

- Capturing details of the authentication between a client and server and using those details to assume the client's identity

- Tricking the client into thinking the attacker's system is the server, acting as the intermediary as the client sets up a legitimate connection with the server, and then disconnecting the client

- Accessing a web application using the cookie data of a user who did not properly close the connection or of a poorly designed application that does not properly manage authentication cookies

All of these techniques can have disastrous results for the end user and must be addressed with both administrative controls (such as anti-replay authentication techniques) and application controls (such as expiring cookies within a reasonable period of time).
